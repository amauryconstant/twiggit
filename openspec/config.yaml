schema: spec-driven

context: |
  Domain: Pragmatic git worktree management tool with context-aware operations
  optimized for rebase workflows across multiple projects.

  Architecture (DDD-Light, 5 layers):
  - cmd/                    → Presentation (Cobra CLI, ServiceContainer, error formatting)
  - internal/application/   → Interface contracts (service interfaces only, no implementations)
  - internal/service/       → Business logic (implements application interfaces)
  - internal/domain/        → Core domain (entities, value objects, errors, validation, NO external deps)
  - internal/infrastructure/→ External integrations (git, config, shell, context detection)

  Dependency Flow:
    cmd → application interfaces → service implementations → infrastructure → domain types
                                ↘ domain (validation, errors) ↗

  Key Architectural Patterns:
  - Interface-Implementation Separation: application/ defines contracts, service/ implements
  - Composite GitClient: Routes to GoGitClient (read ops) or CLIClient (worktree ops)
  - Constructor Injection: All dependencies passed via constructors
  - Domain Error Wrapping: Each layer wraps errors with context using domain types
  - Context-Aware Operations: Detection → Resolution → Execution

  Layer Responsibilities:
  - cmd: Parse CLI args, call services, format output, handle exit codes
  - application: Define service interfaces (WorktreeService, ProjectService, etc.)
  - service: Orchestrate domain logic, validate requests, wrap infrastructure errors
  - domain: Pure business rules, entities, validation, error types (NO imports from other layers)
  - infrastructure: Git operations, config loading, shell integration, path utilities

  Context Types (domain layer):
  - ContextProject: Inside a project's main repository
  - ContextWorktree: Inside a worktree (subdirectory under Worktrees/)
  - ContextOutsideGit: Not in any git repository
  - Detection priority: worktree folder > project folder > outside git

  Default Paths:
  - Projects: $HOME/Projects/<project>/
  - Worktrees: $HOME/Worktrees/<project>/<branch>/

  Tech stack: Go 1.21+, Cobra, go-git, Koanf, Testify, Ginkgo/Gomega, Carapace
  Tooling: mise, golangci-lint, pre-commit, GoReleaser

  Code conventions:
  - NO comments in code unless explicitly requested
  - Tests written AFTER implementation to anchor behavior and specs
  - Table-driven tests with fixtures
  - Constructor injection with interfaces
  - ValidationError returned directly (not wrapped); other errors wrapped with domain types
  - Use errors.As() for type checking, not string matching

  Error Handling:
  - ValidationError: Return directly (already has context)
  - Service errors: Wrap with domain.New*ServiceError()
  - Infrastructure errors: Wrap with domain.NewGit*Error(), domain.NewConfigError()
  - Use fmt.Errorf("operation failed: %w", err) only when no domain error applies

  Testing approach:
  - Unit tests (Testify) in service/ and domain/ with mocks
  - Integration tests (Testify) in test/integration/ with real git repos
  - E2E tests (Ginkgo/Gomega) in test/e2e/ with built binary
  - cmd/ tested via E2E only (no unit tests)

  Development workflow:
  - Use mise run <task> for all operations
  - Run mise run check before committing
  - Pre-commit hooks: whitespace, YAML/TOML validation, merge conflict detection

rules:
  proposal:
    - Typically include: Why, What Changes, Capabilities, Impact
    - Focus on user value and problem statement first
    - Include "Non-goals" section to constrain scope
    - List all affected files organized by layer (cmd, service, domain, infrastructure)
    - Document breaking changes explicitly when applicable
    - Keep proposals concise and actionable

  specs:
    - Use SHALL for mandatory requirements (testable)
    - Scenarios use WHEN/THEN/AND format only
    - Ensure scenarios are concrete with specific inputs and expected outputs
    - Include both positive and negative scenarios
    - Requirements grouped logically with clear purpose statements

  design:
    - Include Context (current state, constraints, assumptions)
    - Goals state what will be achieved; Non-Goals state what is out of scope
    - Decisions are numbered with Choice, Rationale, Alternatives considered
    - Use SHALL/SHOULD for architectural constraints
    - Include Risks/Trade-offs section with specific mitigations
    - Reference related specs, proposals, or design decisions

  tasks:
    - Group by layer: cmd, service, domain, infrastructure, test
    - Use checkbox format for items
    - Tasks are small, clear, and independently verifiable
    - Tests written AFTER implementation to anchor code to specs
    - Include specific file paths and function/method names
    - Add verification steps: mise run check, mise run lint:fix, mise run test
    - Mark completed items with [x]
    - Tasks ordered logically with dependencies clear
