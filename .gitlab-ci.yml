stages:
  - build-base
  - setup
  - build-docker-image
  - test
  - tag
  - mirror

workflow:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"'
    - when: never

# ------------------------
# Global cache for mise + Go modules
# ------------------------
.default_cache: &default_cache
  cache:
    key:
      files:
        - .mise.toml
        - go.sum
    paths:
      - .local/share/mise
      - .cache/mise
      - go/pkg/mod
      - go/bin

# ------------------------
# Build base image (Alpine + pinned mise)
# ------------------------
build-base-image:
  stage: build-base
  image: docker:28.4
  services:
    - docker:28.4-dind
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_DRIVER: overlay2
    DOCKER_BUILDKIT: 1
    BASE_IMAGE_TAG: $CI_REGISTRY_IMAGE/base:$CI_COMMIT_SHA
  script:
    - echo "üê≥ Building base image (Alpine + mise)..."
    - docker buildx build \
        --cache-from=type=registry,ref=$CI_REGISTRY_IMAGE/base:cache \
        --cache-to=type=registry,ref=$CI_REGISTRY_IMAGE/base:cache,mode=max \
        --tag $BASE_IMAGE_TAG \
        --tag $CI_REGISTRY_IMAGE/base:latest \
        -f Dockerfile \
        --push .
    - echo "‚úÖ Base image built and pushed"
  rules:
    - changes:
        - Dockerfile

# ------------------------
# Setup tools (mise install)
# ------------------------
setup-tools:
  stage: setup
  image: $CI_REGISTRY_IMAGE/base:latest
  <<: *default_cache
  variables:
    MISE_TRUSTED_CONFIG_PATHS: $CI_PROJECT_DIR
  script:
    - echo "üîß Installing tools via mise..."
    - mise trust
    - mise install
  rules:
    - when: always

# ------------------------
# Build CI Docker image
# ------------------------
build-docker-image:
  stage: build-docker-image
  image: docker:28.4
  services:
    - name: docker:28.4-dind
      alias: docker
      command: ["--tls=false", "--host=tcp://0.0.0.0:2376"]
  resource_group: docker_build
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_DRIVER: overlay2
    DOCKER_BUILDKIT: 1
    DOCKER_CONTENT_TRUST: 1
    IMAGE_TAG: $CI_COMMIT_SHA
    CACHE_IMAGE: $CI_REGISTRY_IMAGE/twiggit-ci:cache
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login "$CI_REGISTRY" -u "$CI_REGISTRY_USER" --password-stdin
  script:
    - echo "üê≥ Building CI Docker image..."
    - |
      # Extract CLI version from go.mod
      CLI_VERSION=$(grep "// Version:" go.mod | awk '{print $3}')
      echo "CLI version: $CLI_VERSION"
    - docker buildx build \
        --build-arg BUILDKIT_INLINE_CACHE=1 \
        --cache-from=type=registry,ref=$CACHE_IMAGE \
        --cache-to=type=registry,ref=$CACHE_IMAGE,mode=max \
        --tag $CI_REGISTRY_IMAGE/twiggit-ci:$IMAGE_TAG \
        --tag $CI_REGISTRY_IMAGE/twiggit-ci:latest \
        --tag $CI_REGISTRY_IMAGE/twiggit-ci:v$CLI_VERSION \
        --push \
        .
    - echo "‚úÖ CI Docker image built and pushed with version tag v$CLI_VERSION"
  after_script:
    - docker system prune -f
    - docker volume prune -f
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      changes:
        - Dockerfile

# ------------------------
# Test job
# ------------------------
test:
  stage: test
  image: $CI_REGISTRY_IMAGE/twiggit-ci:$CI_COMMIT_SHA
  needs: [setup-tools, build-docker-image]
  <<: *default_cache
  before_script:
    - eval "$(mise activate bash)"
    - export PATH="$(go env GOPATH)/bin:$PATH"
    - go mod download
    - go mod verify
  script:
    - echo "üß™ Running tests..."
    - mise run test
    - mise run lint:check
  coverage: '/total:\s+\(statements\)\s+(\d+\.\d+)%/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
    paths:
      - coverage.html
      - coverage.xml

# ------------------------
# Version tag & release
# ------------------------
create-version-tag:
  stage: tag
  image: $CI_REGISTRY_IMAGE/twiggit-ci:$CI_COMMIT_SHA
  needs: [setup-tools, test, build-docker-image]
  <<: *default_cache
  script:
    - eval "$(mise activate bash)"
    - mise run ci:update-deps
    - echo "üè∑Ô∏è Creating Git tag & GitLab release..."
    - |
      CURRENT_VERSION=$(cat VERSION)
      TAG="v$CURRENT_VERSION"
      git config --global user.email "$GITLAB_USER_EMAIL"
      git config --global user.name "$GITLAB_USER_NAME"
      git remote set-url origin "https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/${CI_PROJECT_PATH}.git"
      git fetch --tags --prune
      if ! git tag -l "$TAG" | grep -q "$TAG"; then
        git tag -a "$TAG" -m "Release $TAG"
        git push origin "$TAG"
      fi
      # Create GitLab release
      curl --header "PRIVATE-TOKEN: $CI_JOB_TOKEN" \
           --header "Content-Type: application/json" \
           --data "{
             \"name\": \"Release $CURRENT_VERSION\",
             \"tag_name\": \"$TAG\",
             \"description\": \"Automated release\"
           }" \
           --request POST "$CI_API_V4_URL/projects/$CI_PROJECT_ID/releases" || true
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"'
  artifacts:
    paths:
      - coverage.html
      - coverage.xml
    expire_in: 1 week

# ------------------------
# Mirror to GitHub
# ------------------------
mirror-to-github:
  stage: mirror
  image: $CI_REGISTRY_IMAGE/twiggit-ci:$CI_COMMIT_SHA
  needs: [setup-tools, build-docker-image]
  <<: *default_cache
  script:
    - eval "$(mise activate bash)"
    - |
      if [ -z "$GITHUB_ACCESS_TOKEN" ] || [ -z "$GITHUB_REPO_URL" ]; then
        echo "ERROR: GITHUB_ACCESS_TOKEN or GITHUB_REPO_URL not set"
        exit 1
      fi
      git remote add github "https://${GITHUB_ACCESS_TOKEN}@github.com/${GITHUB_REPO_URL}.git"
      git push github HEAD:$CI_COMMIT_BRANCH --force-with-lease --tags
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
