stages:
  - build-docker-image
  - setup
  - test
  - tag
  - mirror

workflow:
  rules:
    # Run on merge requests
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'

    # Run on pushes to main
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"'

    # Run on version tags (vX.Y.Z)
    - if: '$CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+$/'

    - when: never

# ------------------------
# Build minimal CI Docker image (Alpine + minimal deps)
# ------------------------
build-docker-image:
  stage: build-docker-image
  image: docker:28.4
  services:
    - docker:28.4-dind
  resource_group: docker_build
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
    DOCKER_DRIVER: overlay2
    DOCKER_BUILDKIT: 1
    DOCKER_CONTENT_TRUST: 1
    MISE_VERSION: v2025.9.13
    IMAGE_TAG: $MISE_VERSION
    CACHE_IMAGE: $CI_REGISTRY_IMAGE/twiggit-ci:cache
    GIT_STRATEGY: fetch
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login "$CI_REGISTRY" -u "$CI_REGISTRY_USER" --password-stdin
    - docker buildx create --use --driver docker-container --name builder
    - docker buildx inspect --bootstrap
  script:
    - if docker manifest inspect $CI_REGISTRY_IMAGE/twiggit-ci:$IMAGE_TAG > /dev/null 2>&1; then echo "‚úÖ Image exists, skipping build" && exit 0; fi
    - echo "üê≥ Building minimal Twiggit CI Docker image..."
    - >
      docker buildx build
      --build-arg BUILDKIT_INLINE_CACHE=1
      --build-arg MISE_VERSION=$MISE_VERSION
      --cache-from=type=registry,ref=$CACHE_IMAGE
      --cache-to=type=registry,ref=$CACHE_IMAGE,mode=max
      --tag $CI_REGISTRY_IMAGE/twiggit-ci:$IMAGE_TAG
      --tag $CI_REGISTRY_IMAGE/twiggit-ci:latest
      --push
      .
    - echo "‚úÖ Minimal CI Docker image built and pushed"
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      changes:
        - Dockerfile

# ------------------------
# Defaults
# ------------------------
.defaults:
  image: $CI_REGISTRY_IMAGE/twiggit-ci:latest
  variables:
    MISE_VERSION: v2025.9.13
    MISE_ENV: ci
    MISE_DATA_DIR: $CI_PROJECT_DIR/.mise/data
    MISE_CACHE_DIR: $CI_PROJECT_DIR/.mise/cache
    GOPATH: $CI_PROJECT_DIR/.go
  cache:
    key:
      files:
        - .ci-cache-key
      prefix: tools-
    paths:
      - $MISE_DATA_DIR
      - $MISE_CACHE_DIR
      - $GOPATH/pkg/mod/
    policy: pull

# ------------------------
# Setup stage - Install and cache all tools
# ------------------------
setup-tools:
  stage: setup
  extends: .defaults
  cache:
    policy: pull-push  # This job updates the cache
  before_script:
    - echo "üîë Generating cache key..."
    - cat .mise/config.toml .mise/config.ci.toml go.sum | sha256sum | cut -c1-16 > .ci-cache-key
  script:
    - echo "‚öôÔ∏è  Configuring mise..."
    - mise settings set experimental true
    - echo "üöÄ Installing all tools..."
    - mise install
    - echo "üì• Downloading Go modules..."
    - mise x -- go mod download
    - mise x -- go mod verify
    - echo "üîç Validating tool installations..."
    - mise --version
    - mise x -- go version
    - mise x -- golangci-lint --version
    - echo "‚úÖ All tools installed and cached successfully!"
  artifacts:
    paths:
      - .ci-cache-key
    expire_in: 1 hour
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"'
    - if: '$CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+$/'

# ------------------------
# Test job - Uses cached tools
# ------------------------
test:
  stage: test
  extends: .defaults
  script:
    - echo "üß™ Running unit tests with coverage..."
    - mise x -- go test -short -coverprofile=coverage_unit.out -covermode=atomic ./...
    - echo "üîç Running integration tests with coverage..."
    - mise x -- go test -tags=integration -coverprofile=coverage_integration.out -covermode=atomic ./test/integration/...
    - echo "üìä Merging coverage profiles..."
    - |
      if [ -s coverage_integration.out ] && [ $(grep -c "^[^m]" coverage_integration.out) -gt 1 ]; then
        mise x -- go run github.com/wadey/gocovmerge@latest coverage_unit.out coverage_integration.out > coverage.out
      else
        echo "Integration coverage is empty, using unit coverage only"
        cp coverage_unit.out coverage.out
      fi
    - echo "üèÉ Running race condition tests..."
    - mise run test:race
    - echo "üî® Building CLI for E2E tests..."
    - mise run build:e2e
    - echo "üéØ Running end-to-end tests..."
    - mise run test:e2e
    - echo "üìä Converting coverage to HTML and XML..."
    - mise x -- go tool cover -html=coverage.out -o coverage.html
    - mise x -- gocover-cobertura < coverage.out > coverage.xml
  coverage: '/^total:.*\s+(\d+\.\d+)%$/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
    paths:
      - coverage.html
      - coverage.xml

# ------------------------
# Version tag & GitLab release
# ------------------------
create-version-tag:
  stage: tag
  extends: .defaults
  before_script:
    - git config user.email "$GITLAB_USER_EMAIL"
    - git config user.name "$GITLAB_USER_NAME"
    - git remote set-url origin "https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/amoconst/twiggit"
  script:
    - |
      echo "üè∑Ô∏è  Determining version..."
      if [ -f VERSION ]; then
        CURRENT_VERSION=$(cat VERSION)
      else
        CURRENT_VERSION=$(grep "// Version:" go.mod | awk '{print $3}')
      fi
      export TAG="v$CURRENT_VERSION"
      echo "Current version: $CURRENT_VERSION"
      echo "Creating tag: $TAG"
    - git fetch --tags --prune
    - |
      if git tag -l "$TAG" | grep -q "$TAG"; then
        echo "‚úÖ Tag $TAG already exists, skipping creation"
      else
        echo "üè∑Ô∏è  Creating new tag $TAG..."
        git tag -a "$TAG" -m "Release $TAG"
        git push origin "$TAG"
        echo "‚úÖ Tag $TAG created and pushed successfully"
      fi
    # Create GitLab Release
    - |
      echo "üì¶ Creating GitLab Release..."
      RESPONSE=$(curl -s -o response.json -w "%{http_code}" \
        --header "PRIVATE-TOKEN: $CI_JOB_TOKEN" \
        --header "Content-Type: application/json" \
        --data "{
          \"name\": \"Release $TAG\",
          \"tag_name\": \"$TAG\",
          \"description\": \"Automated release for version $TAG\",
          \"assets\": {
            \"links\": [
              {\"name\": \"Coverage Report (HTML)\", \"url\": \"$CI_PROJECT_URL/-/jobs/$CI_JOB_ID/artifacts/file/coverage.html\"},
              {\"name\": \"Coverage Report (XML)\", \"url\": \"$CI_PROJECT_URL/-/jobs/$CI_JOB_ID/artifacts/file/coverage.xml\"}
            ]
          }
        }" \
        --request POST "$CI_API_V4_URL/projects/$CI_PROJECT_ID/releases")

      if [ "$RESPONSE" -ne 201 ] && [ "$RESPONSE" -ne 409 ]; then
        echo "‚ùå Release API failed (HTTP $RESPONSE)"
        cat response.json
        exit 1
      fi
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"'
  artifacts:
    paths:
      - coverage.html
      - coverage.xml
    expire_in: 1 week

# ------------------------
# Mirror to GitHub
# ------------------------
mirror-to-github:
  stage: mirror
  extends: .defaults
  before_script:
    - |
      if [ -z "$GITHUB_ACCESS_TOKEN" ]; then
        echo "ERROR: GITHUB_ACCESS_TOKEN is not set"
        exit 1
      fi
      if [ -z "$GITHUB_REPO_URL" ]; then
        echo "ERROR: GITHUB_REPO_URL is not set (format: username/repository)"
        exit 1
      fi
  script:
    - git remote add github "https://${GITHUB_ACCESS_TOKEN}@github.com/${GITHUB_REPO_URL}.git"
    - git fetch github
    - git push github HEAD:$CI_COMMIT_BRANCH --tags
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
